---
title: C언어 문법정리 2
author: 함보라
date: 2022-06-08 18:26:00 +0900
categories: [c언어, 문법]
tags: [개발자, 초보, 문법]
pin: true
---

## C언어 문법정리

> 2차원 포인터

- 2차원 포인터는 * 키워드를 두 개 사용해서 선언한다.
- 2차원 포인터는 1차원 포인터의 주소 값을 저장한다.

![a1](https://gkaqhfk.github.io/assets/img/2차원 포인터 사용하여 일반 변수의 값 대입.png)

**2차원 포인터 사용하여 일반 변수의 값 대입

![a1](https://gkaqhfk.github.io/assets/img/2차원 포인터 일반변수 대입 값.png)

**2차원 포인터 일반변수 대입 값

> 2차원 포인터와 함수의 매개변수

![a1](https://gkaqhfk.github.io/assets/img/2차원 포인터로 8바이트 동적 메모리를 할당하는 함수 만들기.png)

**2차원 포인터로 8바이트 동적 메모리를 할당하는 함수 만들기
-free함수로 할당된 동적 메모리를 해체 한 뒤, p :NULL 값을 넣어줘야 프로그램이 죽지 않는다.

> 2차원 포인터와 2차원 배열

- 포인터는 배열과 유사하지만 같지는 않다. 포인터가 더 넓은 범위를 가지고 있다.

![a1](https://gkaqhfk.github.io/assets/img/2차원 포인터로 연령별 윗몸일으키기 횟수 관리하기.png)

**2차원 포인터로 연령별 윗몸일으키기 횟수 관리하기

![a1](https://gkaqhfk.github.io/assets/img/2차원 포인터로 연령별 윗몸일으키기 횟수 구한 값.png)

**2차원 포인터로 연령별 윗몸일으키기 횟수 구한 값

> dypedef 문법

- 기존의 자료형 중에 자료형 이름의 길이가 긴 경우 프로그래머가 짧고 간결하게 자료형을 재정의 하는 문법
- 기존의 자료형을 다른 이름을 새롭게 재정의 한다.
- dypedef 키워드를 뺀 나머지 부분이 변수를 선언하는 형태와 같다는 특징이 있어서 변수 선언과 착각하지 않도록 자료형의 이름을 대문자로 적는 경우가 많다.

![a1](https://gkaqhfk.github.io/assets/img/typedef로 정의한 자료형으로 변수 선언.png)

**typedef로 정의한 자료형으로 변수 선언

![a1](https://gkaqhfk.github.io/assets/img/typedef로 정의한 자료형으로 변수 선언 값.png)

**typedef로 정의한 자료형으로 변수 선언 값

> 구조체로 선언한 변수의 요소 사용하기

- 구조체로 묶인 데이터는 각 요소의 크기가 같지 않기 때문에 사용할 요소의 이름을 직접 지어 주어야 한다.\
- 구조체로 선언한 변수는 .(요소지정) 연산자와 자신이 사용할 요소의 이름을 함께 적어서 사용한다.

ex) 구조체 변수 이름.사용할 요소

![a1](https://gkaqhfk.github.io/assets/img/구조체를 사용해서 사람의 신체 정보를 입력 받고 출력하기.png)

**구조체를 사용해서 사람의 신체 정보를 입력 받고 출력하기

![a1](https://gkaqhfk.github.io/assets/img/구조체를 사용해서 사람의 신체 정보를 입력 받고 출력한 값.png)

**구조체를 사용해서 사람의 신체 정보를 입력 받고 출력한 값

> 구조체로 선언한 변수를 포인터로 사용하기

*구조체 내부 요소에 접근 하려면 *(주소지정) 연산자를 사용해서 data 변수의 주소로 이동한 다음 .(요소지정) 연산자를 사용해야 한다. 그런데 * 연산자가 .연산자보다 우선 순위가 낮아서 
*p.age=23; 처럼 사용하면 오류가 발생한다. 따라서 *연산자가 먼저 수행되도록 괄호()를 사용해서 (*p).age = 23; 형태로 명령문을 구성해야 한다.

> 연산자 우선순위 문제를 해결하는 -> 연산자

*구조체로 선언한 변수를 포인터 문법으로 사용할 때 마다 (*p) 형태를 사용한다면 매우 불편하다
*이러한 문제를 해결할 수 있는 -> 연산자는 *연산자와 .연산자를 각각 사용하지 않고 하나의 연산자로 사용하기 때문에 연산자 우선순위 문제가 자연스럽게 해결된다.

ex) (*p).age = 23; = p ->age = 23;

> 구조체를 활용한 연결리스트

- 연결리스트는 데이터를 저장할 때 데이터의 개수를 예상 할 수 없고 그 범위가 너무 넓을 때 사용한다.
- 프로그램에서 사용할 데이터 저장 공간을 낭비하지 않을 수 있다.

> 연결리스트의 노드를 구조체로 선언하기

- 연결 리스트에서 숫자와 포인터를 함께 저장하기 위해 할당한 메모리를 노드(Node)라고 부른다.

*연결리스트로 더하기 프로그램 만들기

![a1](https://gkaqhfk.github.io/assets/img/사용자에게 숫자를 입력 받아 합산해 출력1.png)

![a1](https://gkaqhfk.github.io/assets/img/사용자에게 숫자를 입력 받아 합산해 출력2.png)

**사용자에게 숫자를 입력 받아 합산해 출력

![a1](https://gkaqhfk.github.io/assets/img/사용자에게 숫자를 입력받아 합산해 출력한 값.png)

**사용자에게 숫자를 입력받아 합산해 출력한 값






